# TCP 서버 클라이언트.

- 수신할 데이터의 크기를 파악하는것이 힘들 때 어떻게 구현 해야 하는가 ?
    - 이럴때 필요한 겂이 어플리케이션 프로토콜의 정의.
    - 데이터의 송수신 과정에서 데이터의 끝을 알 수 있는 약속을 별도로 정의해야 한다.
    - 데이터의 끝을 표현해놓거나, 송수신될 데이터의 크기를 미리 알려준다던지 해야한다.

- 계산기 서버/클라이언트 예제를 만들어보자.

- 프로토콜 정의
    - 클라이언트는 서버에 접속하자 마자 피연산자의 개수 정보를 1바이트 정수형태로 전달
    - 클라이언트가 서버에 전달하는 정수 하나는 4바이트로 표현한다.
    - 정수를 전달할 때에는 연산의 종류를 전달한다. 연산정보는 1바이트로 전달한다.
    - 문자 +, -, * 중 하나를 선택해서 전달한다.
    - 서버는 연산결과를 4바이트 정수의 형태로 클라이언트에게 전달한다.
    - 연산결과를 얻은 클라이언트는 서버와의 연결을 종료한다.


### 배열, 포인터 in tcp

- 하나의 배열에 다양한 자료를 넣어 처리하기 위해서는
    - char 배열이 많이 사용된다(1바이트여서)

- 예를들어 `char msg[1024]`로 선언하면 0~1023의 총 1024개의 1바이트 배열이 생기는데..
- 여기다가 내가 4바이트 정수형을 우겨넣고 싶다면..

```c
#define SZ 4 //int 4bytes

int main(){
    char msg[1024];
    *(int *)&msg[0] = 23453;
    for (int i = 0; i = 5; i ++){
        *(int *)&msg[i*SZ] = 123445;
    }
}
```

- 이렇게 포인터 형변환을 해서 우겨넣어주면 된다 ㅋㅋ TCP 코딩에서 자주 사용하는 기법인가 봄.


### TCP의 이론적인 이야기.

- TCP 소켓의 데이터 송수신에는 경계가 없다.
- 서버가 40bytes를 write해서 보내도 클라이언트는 네번의 read 함수 호출을 통해 10바이트씩 수신도 가능하다.
- write()함수를 호출하는 순간이 데이터가 전송되는 순간이 아니고, read를 호출하는 순간이 데이터가 수신되는 순간이 아니다.
- write()함수가 호출되는 순간 데이터는 출력 버퍼로 이동, read()함수가 출력되는 순간 데이터는 입력버퍼에 저장된 데이터를 읽어들이게 됨.
